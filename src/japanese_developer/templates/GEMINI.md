# Gemini CLI 汎用コーディングルール

## 言語ルール（最優先）

- **すべての出力を日本語で行うこと。** コード中のコメント、コミットメッセージ、説明、質問、すべて日本語。
- 英語で話しかけられても日本語で返答せよ。
- コード中の変数名・関数名は英語のままでよいが、コメントやドキュメントは日本語。
- UIのラベル・ボタン・エラーメッセージも日本語にする（例: `Submit` → `送信する`、`Cancel` → `やめる`）。

---

## 作業フロー（必須）

### 1. 作業単位ごとにコミット＆プッシュ

ひとつの作業（機能追加、バグ修正、リファクタリング等）が完了したら、**必ず**以下を実行すること：

```bash
git add -A
git commit -m "簡潔な変更内容の説明"
git push
```

これは「セーブポイント」である。作業を失わないために絶対に省略しない。

### 2. 作業ログの自動記録

プロジェクトには **`logs/`** ディレクトリを必ず設置する。存在しなければ作成すること。

コミット時に以下の2ファイルへ自動記録される（hookが処理）：

**統合ログ `logs/WORK_LOG.md`** — 全ブランチ・全作業者の時系列ログ：
```markdown
## YYYY-MM-DD HH:MM [ブランチ名] @作業者名

- **意図**: 何をしたか・なぜやったか
- **変更ファイル**: 主要な変更ファイルのリスト
- **コミット**: コミットハッシュ（短縮形）
```

**ブランチログ `logs/<ブランチ名>_<作業者名>.md`** — ブランチ単位の作業履歴：
```markdown
# feature-login / shimatoshi

- **開始日**: 2026-02-26
- **ベース**: main v1.2.3

---

## 2026-02-26 14:30

- **意図**: ログイン画面の雛形作成
- **変更ファイル**: login.html, auth.js
- **コミット**: a1b2c3d
```

**ルール:**
- ログは自動追記。過去のログは絶対に消さない。
- `logs/` ディレクトリはリポジトリに含める（.gitignoreに入れない）。
- 途中からプロジェクトに参加した人が「いつ誰が何をやったか」を一目で把握できることが目的。

### PR連携

- **PR作成時**: ブランチログの内容をPR bodyに含めること。
- **push時**: PRが存在する場合、hookが自動で作業ログコメントを投稿する。
  - 今回のコミット一覧 + ブランチログ全文を折りたたみで添付。

### 3. プロジェクト使用手順書の発行

プロジェクトに変更を加えた際、プロジェクトルートに **`USAGE.md`** が存在しなければ必ず作成すること。
既に存在する場合は、変更内容に応じて更新すること。

`USAGE.md` には以下を含める：

```markdown
# プロジェクト名

## 起動方法
（サーバー起動コマンド、必要な環境変数、前提条件など）

## 使い方
（基本的な操作手順、エンドポイント一覧など）

## 停止方法
（停止コマンド、後片付け手順など）
```

**目的**: 誰がいつこのプロジェクトを触っても、すぐに動かせる状態を維持する。

### 4. サーバー起動ルール

シェル内でサーバーを起動するとCLIが進行不能になるため、以下のルールで運用する。

**常駐サーバー（Vite等の開発サーバー）:**
- シェル内で直接起動してはならない。
- ユーザーに「別のターミナルで `npm run dev` を起動してください」と依頼すること。

**一時サーバー（APIの動作確認等）:**
- 起動 → `curl` 等で挙動確認 → 即停止、の流れは許可する。
- 確認が終わったら必ずプロセスを停止すること。放置厳禁。
- 例: `python server.py & sleep 2 && curl http://localhost:8080/api/health && kill %1`

---

## コード品質

### リファクタリング方針

- **肥大化を未然に防ぐ**ことを最優先とする。
- 1つのファイルが **300行を超え始めたら**、責務の分割を検討せよ。
- 1つの関数が **50行を超え始めたら**、処理の分割を検討せよ。
- ただし「今必要でないリファクタリング」は行わない。将来の仮説的要件のための抽象化は禁止。
- リファクタリングを行う場合は、**独立した作業単位**として実行し、機能追加と同じコミットに混ぜない。

### 変更前の原則

- **既存コードを必ず読んでから変更する。** 読んでいないコードへの変更提案は禁止。
- 既存のコーディングスタイル・パターンに従う。独自の流儀を持ち込まない。
- 変更の影響範囲を確認してから着手する。

### やってはいけないこと

- 頼まれていない機能追加・改善・整理
- 不要なコメント・docstring・型注釈の追加
- 使われていないコードを残す（削除してよい）
- 動いているコードの「念のため」エラーハンドリング追加

---

## 開発環境

- **開発環境**: Termux (Android)
- **デプロイ先サーバー**: dynabook（自宅サーバー）
- 接続情報・APIキー等は `~/.gemini/ENV.md` を参照すること。

### 5. Viteによるリアルタイム動作確認

フロントエンドの変更を行う場合、**必ずVite開発サーバーでリアルタイム確認を行う**こと。

- 言語やフレームワークに関わらず、フロントエンドにはViteを使用する。
- Viteが未導入のプロジェクトには導入を提案すること。
- 変更を加えたら、Vite経由でブラウザ上の表示・挙動を確認してから次の作業に進む。
- Viteの起動はユーザーに別ターミナルでの起動を依頼する（上記「サーバー起動ルール」参照）。

---

## バージョン管理

### バージョン番号の表記ルール

すべてのフロントエンドプロジェクトは、**画面上部にバージョン番号を常時表示**すること。

**mainブランチ:**
```
v1.2.3
```
- セマンティックバージョニング（メジャー.マイナー.パッチ）
- コミットごとにパッチを `+0.0.1` 進める

**featureブランチ:**
```
v1.2.3 > feature-login / shimatoshi v0.0.4
ベース    ブランチ名       作者      ブランチ内バージョン
```
- ブランチ内バージョンもコミットごとに `+0.0.1` で独立して進める
- ベースバージョンは、ブランチ作成時のmainバージョンを記載

**mainへのマージ時:**
- マージ後のmainバージョンは、現在のmainバージョンから `+0.0.1`
- 例: main `v1.2.3` にブランチをマージ → main `v1.2.4`

### アップデートボタン（必須）

フロントエンドには**アップデートボタン**を設置すること。

- ボタン押下時の挙動:
  1. Service Workerのキャッシュをクリア（静的アセットのみ）
  2. 最新版を取得してページをリロード
  3. **localStorage / IndexedDB のデータは保持する**（消さない）
- ボタン押下時に確認メッセージを表示: 「アプリを最新版に更新します。保存済みデータはそのまま残ります。」
- 新しいバージョンが検出された場合、バージョン表示の横に更新バッジを出すことを推奨。

---

## PWA対応

フロントエンドは **PWA（Progressive Web App）化を前提** として構築する。

### 必須（全プロジェクト）

- `manifest.json` の作成（アプリ名、アイコン、テーマカラー、`display: standalone`）
- Service Worker の登録
- ホーム画面追加（A2HS）対応

### 推奨（ネットワーク不安定な環境向け）

- オフラインフォールバックページ
- 静的アセットのプリキャッシュ

### 任意（明示的に要求された場合のみ）

- プッシュ通知
- バックグラウンド同期

**注意**: PWA対応がプロジェクトの要件と競合する場合（既存のキャッシュ戦略との衝突等）は、ユーザーに確認してからレベルを調整すること。

---

## 成果物の設計基準

### モバイルファースト

- 縦スクロール基本。横並びカラムはレスポンシブ対応必須。
- viewport メタタグ必須: `<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">`
- タッチターゲットは高さ48px以上。hover前提の機能は禁止。

### デザイン

- ダークモード基調。
- CLIのような素っ気ない画面は避け、ヘッダー・コンテンツ・フッターのあるアプリ的UI構造にする。
- エラーは人間の言葉で表示（「ページが見つかりません」等）。

---

## ファイル操作権限

ファイルの作成・削除・実行は、ストレージやメモリを著しく圧迫するものでない限り、**ユーザーの許可なく自律的に実行してよい**。
